<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ID Scanner - Parfitt Cresswell</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #B03C5F;
            min-height: 100vh;
            display: flex;
            align-items: flex-start;
            justify-content: center;
            padding: 40px 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.15);
            width: 100%;
            max-width: 500px;
            overflow: hidden;
            border: 3px solid #B03C5F;
            margin-top: 0;
        }

        .header {
            background: white;
            color: #333;
            padding: 30px;
            text-align: center;
            border-bottom: 2px solid #f0f0f0;
        }

        .logo {
            width: 200px;
            height: 60px;
            margin: 0 auto 20px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .logo img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        .header h1 {
            font-size: 28px;
            margin-bottom: 10px;
            font-weight: 300;
            color: #B03C5F;
        }

        .header p {
            opacity: 0.7;
            font-size: 16px;
            font-weight: 300;
            color: #666;
        }

        .content {
            padding: 40px 30px;
        }

        .step {
            display: none;
        }

        .step.active {
            display: block;
        }

        .document-options {
            display: grid;
            gap: 20px;
            margin-top: 20px;
        }

        .doc-button {
            background: #004E92;
            color: white;
            border: none;
            padding: 20px;
            border-radius: 12px;
            font-size: 18px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .doc-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 78, 146, 0.4);
            background: #003d75;
        }

        .btn {
            background: #004E92;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 140px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 78, 146, 0.4);
            background: #003d75;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .btn.secondary {
            background: linear-gradient(135deg, #6c757d 0%, #5a6268 100%);
        }

        .btn.danger {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
        }

        .camera-container {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 12px;
            min-height: 200px;
            margin: 20px 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 48px;
            color: #6c757d;
        }

        video {
            width: 100%;
            border-radius: 12px;
        }

        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .instructions {
            background: #fff3cd;
            border: 1px solid #d4af37;
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
        }

        .instructions h4 {
            color: #856404;
            margin-bottom: 10px;
        }

        .instructions ul {
            color: #856404;
            margin-left: 20px;
        }

        .loading {
            text-align: center;
            padding: 30px;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #a67a7e;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .ocr-results {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
            border: 1px solid #e9ecef;
        }

        .data-item {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            padding: 8px 0;
            border-bottom: 1px solid #dee2e6;
        }

        .data-label {
            font-weight: 600;
            color: #B03C5F;
        }

        .data-value {
            color: #6c757d;
        }

        .raw-text {
            background: #fff;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            font-family: monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
            white-space: pre-wrap;
        }

        .confidence-score {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            padding: 12px 20px;
            border-radius: 25px;
            text-align: center;
            margin: 20px 0;
            font-weight: 600;
        }

        .confidence-score.low {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
        }

        .confidence-score.medium {
            background: linear-gradient(135deg, #ffc107 0%, #e0a800 100%);
            color: #212529;
        }

        .thank-you {
            text-align: center;
            padding: 40px 20px;
        }

        .thank-you h2 {
            color: #B03C5F;
            margin-bottom: 20px;
            font-size: 32px;
        }

        .header-compact {
            background: white;
            padding: 15px 30px;
            text-align: center;
            border-bottom: 1px solid #f0f0f0;
            margin-bottom: 20px;
        }

        .header-compact .logo {
            width: 100%;
            max-width: 300px;
            height: 60px;
            margin: 0 auto;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .next-step-preview {
            background: linear-gradient(135deg, #e3f2fd 0%, #f3e5f5 100%);
            border: 2px solid #B03C5F;
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
            animation: pulse-glow 2s infinite;
        }

        .next-step-preview h3 {
            color: #B03C5F;
            margin: 0 0 10px 0;
            font-size: 18px;
        }

        .next-step-preview p {
            color: #666;
            margin: 0;
            font-size: 14px;
        }

        .next-step-icon {
            font-size: 40px;
            margin-bottom: 10px;
            display: block;
        }

        @keyframes pulse-glow {
            0%, 100% { 
                box-shadow: 0 0 5px rgba(176, 60, 95, 0.3);
                transform: scale(1);
            }
            50% { 
                box-shadow: 0 0 20px rgba(176, 60, 95, 0.6);
                transform: scale(1.02);
            }
        }
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: #28a745;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 30px;
            font-size: 40px;
            color: white;
        }

        @media (max-width: 600px) {
            .container {
                margin: 10px;
            }
            .content {
                padding: 30px 20px;
            }
            .controls {
                flex-direction: column;
                align-items: center;
            }
            .btn {
                width: 100%;
                max-width: 250px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header" id="mainHeader">
            <div class="logo">
                <img src="https://www.parfittcresswell.com/assets/images/pc_logo_new.svg" alt="Parfitt Cresswell Logo">
            </div>
            <h1>ID Scanner</h1>
            <p>Secure Document Verification System</p>
        </div>

        <div class="content">
            <!-- Step 0: ID Reference Entry -->
            <div class="step active" id="step0">
                <h2>Enter ID Reference</h2>
                <p>Please enter your 6-digit ID Reference number:</p>
                <div style="margin: 30px 0;">
                    <input type="text" id="idRefInput" placeholder="e.g., 162024" 
                           style="width: 100%; padding: 15px; font-size: 18px; border: 2px solid #e9ecef; 
                                  border-radius: 10px; text-align: center; letter-spacing: 2px; 
                                  -webkit-appearance: none; appearance: none;"
                           maxlength="6" pattern="16[0-9]{4}" inputmode="numeric">
                </div>
                <div style="text-align: center;">
                    <button class="btn" onclick="validateAndProceed(); return false;" id="proceedToDocSelection" 
                            style="font-size: 18px; padding: 15px 30px; min-width: 200px; 
                                   -webkit-tap-highlight-color: transparent; touch-action: manipulation;">
                        Continue â†’
                    </button>
                </div>
                <div style="background: #e3f2fd; padding: 15px; border-radius: 8px; margin: 20px 0; font-size: 14px; color: #1565c0;">
                    <strong>Format:</strong> 6 digits starting with 16 (e.g., 162024)
                </div>
            </div>

            <!-- Step 1: Document Type Selection -->
            <div class="step" id="step1">
                <div style="text-align: center; margin-bottom: 20px;">
                    <div style="background: #f8f9fa; padding: 10px; border-radius: 8px; display: inline-block;">
                        <strong>ID Reference: <span style="color: #B03C5F;" id="displayIdRef"></span></strong>
                    </div>
                </div>
                <h2>Select Document Type</h2>
                <p>Please choose the type of document you want to scan:</p>
                <div class="document-options">
                    <button class="doc-button" onclick="selectDocument('passport')">
                        <svg width="40" height="56" viewBox="0 0 40 56" style="vertical-align: middle;">
                            <!-- Passport cover - UK Blue -->
                            <rect x="0" y="0" width="40" height="56" rx="3" fill="#1e3a5f" stroke="#152a47" stroke-width="1"/>
                            <!-- Gold accent line -->
                            <rect x="0" y="8" width="40" height="1" fill="#D4AF37" opacity="0.8"/>
                            <rect x="0" y="47" width="40" height="1" fill="#D4AF37" opacity="0.8"/>
                            <!-- Emblem circle -->
                            <circle cx="20" cy="20" r="8" fill="none" stroke="#D4AF37" stroke-width="1.5" opacity="0.8"/>
                            <!-- Crown symbol -->
                            <path d="M15 19 L17 16 L20 17 L23 16 L25 19 L25 21 L15 21 Z" fill="#D4AF37" opacity="0.8"/>
                            <!-- PASSPORT text -->
                            <text x="20" y="38" text-anchor="middle" font-family="Arial, sans-serif" font-size="6" font-weight="bold" fill="#D4AF37" opacity="0.9">PASSPORT</text>
                        </svg>
                        <span style="margin-left: 10px;">Passport</span>
                    </button>
                    <button class="doc-button" onclick="selectDocument('license')">
                        <svg width="54" height="34" viewBox="0 0 54 34" style="vertical-align: middle;">
                            <!-- Card background -->
                            <rect x="0" y="0" width="54" height="34" rx="3" fill="#fdd9d9" stroke="#e0e0e0" stroke-width="0.5"/>
                            <!-- EU flag section -->
                            <rect x="2" y="2" width="10" height="10" rx="1" fill="#003399"/>
                            <!-- EU stars (simplified) -->
                            <circle cx="7" cy="4" r="0.5" fill="#ffcc00"/>
                            <circle cx="9" cy="5" r="0.5" fill="#ffcc00"/>
                            <circle cx="10" cy="7" r="0.5" fill="#ffcc00"/>
                            <circle cx="9" cy="9" r="0.5" fill="#ffcc00"/>
                            <circle cx="7" cy="10" r="0.5" fill="#ffcc00"/>
                            <circle cx="5" cy="9" r="0.5" fill="#ffcc00"/>
                            <circle cx="4" cy="7" r="0.5" fill="#ffcc00"/>
                            <circle cx="5" cy="5" r="0.5" fill="#ffcc00"/>
                            <!-- UK text -->
                            <text x="7" y="8" text-anchor="middle" font-family="Arial, sans-serif" font-size="4" font-weight="bold" fill="white">UK</text>
                            <!-- DRIVING LICENCE text -->
                            <text x="27" y="8" text-anchor="middle" font-family="Arial, sans-serif" font-size="5" font-weight="bold" fill="#003399">DRIVING LICENCE</text>
                            <!-- Photo placeholder -->
                            <rect x="3" y="14" width="12" height="15" rx="1" fill="#e0e0e0" stroke="#ccc" stroke-width="0.5"/>
                            <circle cx="9" cy="19" r="2" fill="#bbb"/>
                            <circle cx="9" cy="24" r="3" fill="#bbb"/>
                            <!-- Text lines representing licence details -->
                            <rect x="18" y="15" width="32" height="1" rx="0.5" fill="#666"/>
                            <rect x="18" y="18" width="28" height="1" rx="0.5" fill="#666"/>
                            <rect x="18" y="21" width="30" height="1" rx="0.5" fill="#666"/>
                            <rect x="18" y="24" width="26" height="1" rx="0.5" fill="#666"/>
                            <rect x="18" y="27" width="32" height="1" rx="0.5" fill="#666"/>
                            <!-- UK flag -->
                            <g transform="translate(44, 22)">
                                <rect x="0" y="0" width="8" height="5" fill="#012169"/>
                                <path d="M0,0 L8,5 M8,0 L0,5" stroke="white" stroke-width="0.8"/>
                                <path d="M0,0 L8,5 M8,0 L0,5" stroke="#C8102E" stroke-width="0.4"/>
                                <path d="M4,0 L4,5 M0,2.5 L8,2.5" stroke="white" stroke-width="1.2"/>
                                <path d="M4,0 L4,5 M0,2.5 L8,2.5" stroke="#C8102E" stroke-width="0.8"/>
                            </g>
                        </svg>
                        <span style="margin-left: 10px;">Driving Licence</span>
                    </button>
                </div>
            </div>

            <!-- Step 2: Document Scanning -->
            <div class="step" id="step2">
                <div class="header-compact">
                    <div class="logo">
                        <img src="https://www.parfittcresswell.com/assets/images/pc_logo_new.svg" alt="Parfitt Cresswell Logo">
                    </div>
                </div>
                <h2>Scan <span id="docType"></span></h2>
                <div id="cameraContainer" class="camera-container">ðŸ“·</div>
                <div class="controls">
                    <button class="btn" onclick="captureDocument()">ðŸ“· Capture Document</button>
                    <button class="btn secondary" onclick="switchCamera()">ðŸ”„ Switch Camera</button>
                </div>
                <div class="instructions">
                    <h4>ðŸ“‹ Capture Instructions:</h4>
                    <ul>
                        <li>Ensure good lighting</li>
                        <li>Hold document flat and steady</li>
                        <li>Fill the frame with your document</li>
                        <li>Avoid glare and shadows</li>
                    </ul>
                </div>
            </div>

            <!-- Step 3: OCR Processing -->
            <div class="step" id="step3">
                <div class="header-compact">
                    <div class="logo">
                        <img src="https://www.parfittcresswell.com/assets/images/pc_logo_new.svg" alt="Parfitt Cresswell Logo">
                    </div>
                </div>
                <h2>Processing Document</h2>
                <div class="loading">
                    <div class="spinner"></div>
                    <p id="processingText">Analyzing document...</p>
                </div>
            </div>

            <!-- Step 4: OCR Results -->
            <div class="step" id="step4">
                <div class="header-compact">
                    <div class="logo">
                        <img src="https://www.parfittcresswell.com/assets/images/pc_logo_new.svg" alt="Parfitt Cresswell Logo">
                    </div>
                </div>
                <h2>Document Analysis Results</h2>
                <div class="confidence-score" id="confidenceScore"></div>
                <div class="controls" style="margin: 15px 0;">
                    <button class="btn danger" onclick="retakeDocument()" 
                            style="font-size: 18px; padding: 15px 30px; min-width: 250px;">
                        ðŸ”„ Retake ID Document Image
                    </button>
                </div>
                
                <div class="next-step-preview" id="nextStepPreview">
                    <span class="next-step-icon">ðŸ¤³</span>
                    <h3>Next: Take Your Photo</h3>
                    <p>After reviewing the results above, you'll need to take a selfie photo for verification</p>
                    <button class="btn" onclick="proceedToPhoto()" 
                            style="margin-top: 15px; background: #B03C5F; font-size: 16px; padding: 12px 24px;">
                        ðŸ“¸ Continue to Photo
                    </button>
                </div>
                
                <div class="ocr-results" id="ocrResults"></div>
            </div>

            <!-- Step 5: Photo Capture -->
            <div class="step" id="step5">
                <div class="header-compact">
                    <div class="logo">
                        <img src="https://www.parfittcresswell.com/assets/images/pc_logo_new.svg" alt="Parfitt Cresswell Logo">
                    </div>
                </div>
                <div style="background: linear-gradient(135deg, #28a745 0%, #20c997 100%); color: white; padding: 15px; border-radius: 10px; text-align: center; margin-bottom: 20px;">
                    <span style="font-size: 24px;">ðŸ“„âœ… â†’ ðŸ¤³</span>
                    <h3 style="margin: 5px 0;">Document Scanned Successfully!</h3>
                    <p style="margin: 0; opacity: 0.9;">Now take a clear photo of yourself for verification</p>
                </div>
                <h2>Take Your Photo</h2>
                <div id="photoContainer" class="camera-container">ðŸ“·</div>
                <div class="controls">
                    <button class="btn" onclick="capturePhoto()">ðŸ“· Take Photo</button>
                    <button class="btn secondary" onclick="switchPhotoCamera()">ðŸ”„ Switch Camera</button>
                </div>
                <div class="instructions">
                    <h4>ðŸ“¸ Photo Instructions:</h4>
                    <ul>
                        <li>Look directly at the camera</li>
                        <li>Remove hats and sunglasses</li>
                        <li>Ensure face is well-lit</li>
                        <li>Keep a neutral expression</li>
                    </ul>
                </div>
            </div>

            <!-- Step 6: Processing -->
            <div class="step" id="step6">
                <div class="header-compact">
                    <div class="logo">
                        <img src="https://www.parfittcresswell.com/assets/images/pc_logo_new.svg" alt="Parfitt Cresswell Logo">
                    </div>
                </div>
                <h2>Finalising Submission</h2>
                <div class="loading">
                    <div class="spinner"></div>
                    <p><strong>Processing your confidential documents...</strong></p>
                    <p style="margin-top: 15px; font-size: 14px; color: #666;">Your information is being securely transmitted to the Risk & Compliance team at Parfitt Cresswell Solicitors.</p>
                    <p style="margin-top: 10px; font-size: 12px; color: #B03C5F;">ðŸ”’ All data is encrypted and handled in strict confidence</p>
                </div>
            </div>

            <!-- Step 7: Thank You -->
            <div class="step" id="step7">
                <div class="header-compact">
                    <div class="logo">
                        <img src="https://www.parfittcresswell.com/assets/images/pc_logo_new.svg" alt="Parfitt Cresswell Logo">
                    </div>
                </div>
                <div class="thank-you">
                    <div class="checkmark">âœ“</div>
                    <h2>Thank You!</h2>
                    <p>Your ID verification has been completed successfully. The document and photo have been securely processed and transmitted to the Risk & Compliance team at Parfitt Cresswell Solicitors for confidential review.</p>
                    <br>
                    <button class="btn" onclick="startOver()">Scan Another Document</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/tesseract.js@4.1.1/dist/tesseract.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script>
        // SMTP2GO configuration
        const SMTP2GO_CONFIG = {
            apiUrl: 'https://api.smtp2go.com/v3/',
            apiKey: 'api-46B81FB9224244EC81CFE27994B4775E'
        };

        // Azure Computer Vision configuration
        const AZURE_CONFIG = {
            endpoint: 'https://id.cognitiveservices.azure.com/',
            apiKey: '5vMDwlr9ChvgIkjqeeYJw9vxDNldvyp2YfT5o2eR0i3p8QVMaEvoJQQJ99BFACmepeSXJ3w3AAAFACOGY602',
            apiVersion: '3.2'
        };

        // Global variables
        let selectedDocType = '';
        let stream = null;
        let currentCamera = 'environment';
        let documentImage = null;
        let photoImage = null;
        let ocrData = null;
        let confidenceScore = 0;
        let idRef = '';
        let currentStep = 0;
        let cameraPermissionGranted = false;

        // Get ID Ref from URL parameters
        function getURLParameter(name) {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get(name);
        }

        // Validate ID Ref format (6 digits starting with 16)
        function validateIDRef(ref) {
            const pattern = /^16\d{4}$/;
            return pattern.test(ref);
        }

        // Validate UK passport number format
        function validatePassportNumber(passportNumber) {
            if (!passportNumber) return false;
            
            // Remove any spaces or special characters
            const cleaned = passportNumber.replace(/[\s\-]/g, '');
            
            // UK passport numbers are 9 digits
            const ukPassportPattern = /^\d{9}$/;
            
            if (ukPassportPattern.test(cleaned)) {
                console.log('Valid UK passport number format:', cleaned);
                return true;
            }
            
            console.log('Invalid passport number format:', passportNumber);
            return false;
        }

        // Validate UK driving licence number format
        function validateDrivingLicenceNumber(licenceNumber) {
            if (!licenceNumber) return false;
            
            // First check if it matches with space and digits at end
            const withSpacePattern = /^[A-Z]{5}\d{6}[A-Z0-9]{5}\s+\d{2}$/i;
            if (withSpacePattern.test(licenceNumber)) {
                console.log('Valid UK driving licence format with space:', licenceNumber);
                return true;
            }
            
            // Remove spaces for other checks
            const cleaned = licenceNumber.replace(/\s/g, '').toUpperCase();
            
            // UK driving licence patterns
            const ukLicencePattern16 = /^[A-Z]{5}\d{6}[A-Z0-9]{5}$/;
            const ukLicencePattern18 = /^[A-Z]{5}\d{6}[A-Z0-9]{5}\d{2}$/;
            
            if (ukLicencePattern16.test(cleaned) || ukLicencePattern18.test(cleaned)) {
                console.log('Valid UK driving licence format:', licenceNumber);
                
                const dateDigits = cleaned.substring(5, 11);
                const month = parseInt(dateDigits.substring(3, 5));
                
                if (month > 0 && month <= 12) {
                    console.log('Licence number date validation passed');
                    return true;
                } else if (month >= 51 && month <= 62) {
                    console.log('Licence number date validation passed (female)');
                    return true;
                }
            }
            
            console.log('Invalid driving licence format:', licenceNumber);
            return false;
        }

        // Enhanced passport data extraction function
        function extractPassportData(text) {
            console.log('=== PASSPORT DATA EXTRACTION ===');
            console.log('Input text:', text);
            
            const data = {};
            
            // Clean and normalize the text
            const cleanText = text.replace(/[^\w\s\/\-\.]/g, ' ').replace(/\s+/g, ' ').trim();
            const lines = text.split('\n').map(line => line.trim()).filter(line => line.length > 0);
            
            console.log('Cleaned text:', cleanText);
            console.log('Lines found:', lines);
            
            // Extract passport number - multiple patterns
            data['Passport Number'] = extractPassportNumber(text, lines);
            
            // Extract surname and given names
            const nameData = extractPassportNames(text, lines);
            data['Surname'] = nameData.surname;
            data['Given Names'] = nameData.givenNames;
            
            // Extract other passport fields
            data['Nationality'] = extractNationality(text, lines);
            data['Date of Birth'] = extractDateOfBirth(text, lines);
            data['Date of Expiry'] = extractDateOfExpiry(text, lines);
            data['Place of Birth'] = extractPlaceOfBirth(text, lines);
            data['Sex'] = extractSex(text, lines);
            
            console.log('Final extracted passport data:', data);
            return data;
        }

        function extractPassportNumber(text, lines) {
            console.log('--- Extracting Passport Number ---');
            
            // UK passport numbers are typically 9 digits
            const patterns = [
                // Direct passport number patterns
                /passport\s*(?:no|number|num)?[:\s]*([0-9]{9})/i,
                /passport[:\s]*([0-9]{9})/i,
                /(?:^|\s)([0-9]{9})(?:\s|$)/,
                
                // Machine readable zone patterns (MRZ) - last line typically contains passport number
                /GBR([0-9]{9})/i,
                /P<GBR([0-9]{9})/i,
                
                // Look for 9 consecutive digits anywhere
                /\b([0-9]{9})\b/,
                
                // Sometimes with spaces or separators
                /([0-9]{3}[\s\-]?[0-9]{3}[\s\-]?[0-9]{3})/,
            ];
            
            for (const pattern of patterns) {
                const match = text.match(pattern);
                if (match) {
                    const passportNum = match[1].replace(/[\s\-]/g, '');
                    if (passportNum.length === 9 && /^\d{9}$/.test(passportNum)) {
                        console.log('Passport number found:', passportNum, 'using pattern:', pattern);
                        return passportNum;
                    }
                }
            }
            
            // Check each line for standalone 9-digit numbers
            for (const line of lines) {
                const digitMatch = line.match(/\b(\d{9})\b/);
                if (digitMatch) {
                    console.log('Passport number found in line:', digitMatch[1]);
                    return digitMatch[1];
                }
            }
            
            console.log('No passport number found');
            return '';
        }

        function extractPassportNames(text, lines) {
            console.log('--- Extracting Names ---');
            console.log('Raw text for name extraction:', text);
            console.log('Lines for analysis:', lines);
            
            let surname = '';
            let givenNames = '';
            
            // Strategy 1: Look for specific passport format patterns
            // UK passports often have: "Surname/Nom (1) SURNAME" and "Given names/PrÃ©noms (2) GIVEN NAMES"
            const ukSurnamePatterns = [
                /Surname\/Nom\s*\(1\)\s+([A-Z]+)/i,
                /surname[\/\s]*nom[^(]*\(1\)\s+([A-Z]+)/i,
                /\(1\)\s+([A-Z]+)(?=\s+Given|\s+PrÃ©n)/i,
            ];
            
            const ukGivenNamePatterns = [
                /Given\s+names?\/PrÃ©noms?\s*\(2\)\s+([A-Z\s]+?)(?=\s+Nationality|\s+British|\s+\(3\))/i,
                /given[^(]*\(2\)\s+([A-Z\s]+?)(?=\s+Nationality|\s+British|\s+\(3\))/i,
                /\(2\)\s+([A-Z\s]+?)(?=\s+Nationality|\s+British|\s+\(3\))/i,
            ];
            
            // Try UK passport specific patterns first
            for (const pattern of ukSurnamePatterns) {
                const match = text.match(pattern);
                if (match) {
                    surname = match[1].trim();
                    console.log('UK Surname found with pattern:', surname, 'using pattern:', pattern);
                    break;
                }
            }
            
            for (const pattern of ukGivenNamePatterns) {
                const match = text.match(pattern);
                if (match) {
                    givenNames = match[1].trim().replace(/\s+/g, ' ');
                    console.log('UK Given names found with pattern:', givenNames, 'using pattern:', pattern);
                    break;
                }
            }
            
            // Strategy 2: Look for general surname/given names labels (fallback)
            if (!surname) {
                const generalSurnamePatterns = [
                    /surname[:\s\/]+([A-Z]+)(?=\s+given|\s+first|\s+prÃ©n)/i,
                    /family\s*name[:\s]+([A-Z]+)/i,
                    /last\s*name[:\s]+([A-Z]+)/i,
                ];
                
                for (const pattern of generalSurnamePatterns) {
                    const match = text.match(pattern);
                    if (match) {
                        surname = match[1].trim();
                        console.log('General surname found:', surname);
                        break;
                    }
                }
            }
            
            if (!givenNames) {
                const generalGivenNamePatterns = [
                    /(?:given\s*names?|first\s*names?|forenames?)[:\s\/]+([A-Z\s]+?)(?=\s+nationality|\s+british|\s+date|\s+sex)/i,
                ];
                
                for (const pattern of generalGivenNamePatterns) {
                    const match = text.match(pattern);
                    if (match) {
                        givenNames = match[1].trim().replace(/\s+/g, ' ');
                        console.log('General given names found:', givenNames);
                        break;
                    }
                }
            }
            
            // Strategy 3: Look for MRZ (Machine Readable Zone) format
            if (!surname || !givenNames) {
                const mrzMatch = text.match(/P<GBR([A-Z]+)<<([A-Z<]+)/i);
                if (mrzMatch) {
                    if (!surname) surname = mrzMatch[1].replace(/</g, ' ').trim();
                    if (!givenNames) givenNames = mrzMatch[2].replace(/</g, ' ').trim();
                    console.log('Names extracted from MRZ - Surname:', surname, 'Given:', givenNames);
                }
            }
            
            // Strategy 4: Parse line by line looking for the name data after numbered fields
            if (!surname || !givenNames) {
                console.log('Trying line-by-line extraction...');
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    console.log(`Line ${i}: "${line}"`);
                    
                    // Look for "(1)" followed by surname
                    if (!surname && /\(1\)/.test(line)) {
                        const match = line.match(/\(1\)\s+([A-Z]+)/);
                        if (match) {
                            surname = match[1];
                            console.log('Surname found in line after (1):', surname);
                        }
                    }
                    
                    // Look for "(2)" followed by given names
                    if (!givenNames && /\(2\)/.test(line)) {
                        const match = line.match(/\(2\)\s+([A-Z\s]+?)(?=\s+[A-Z]+\s+CITIZEN|\s+British|\s+\(3\)|$)/i);
                        if (match) {
                            givenNames = match[1].trim();
                            console.log('Given names found in line after (2):', givenNames);
                        }
                    }
                }
            }
            
            // Strategy 5: Look for standalone name lines (avoiding header text)
            if (!surname || !givenNames) {
                console.log('Trying standalone name detection...');
                for (const line of lines) {
                    // Skip obvious header/title lines
                    if (/passport|united kingdom|great britain|northern ireland|type|code/i.test(line)) {
                        console.log('Skipping header line:', line);
                        continue;
                    }
                    
                    // Look for lines with just uppercase names
                    const cleanLine = line.trim();
                    if (/^[A-Z]{3,}$/.test(cleanLine) && cleanLine.length < 20 && !surname) {
                        // Single word, likely surname
                        surname = cleanLine;
                        console.log('Surname from standalone line:', surname);
                    } else if (/^[A-Z]+\s+[A-Z]+$/.test(cleanLine) && !givenNames) {
                        // Two words, likely given names
                        givenNames = cleanLine;
                        console.log('Given names from standalone line:', givenNames);
                    }
                }
            }
            
            console.log('Final name extraction results - Surname:', surname, 'Given Names:', givenNames);
            
            return {
                surname: surname || '',
                givenNames: givenNames || ''
            };
        }

        function extractNationality(text, lines) {
            const patterns = [
                /nationality[:\s]+([A-Z]+)/i,
                /nat[:\s]+([A-Z]+)/i,
                /(BRITISH|AMERICAN|CANADIAN|GERMAN|FRENCH|ITALIAN|SPANISH)/i,
                /GBR/i, // ISO code
            ];
            
            for (const pattern of patterns) {
                const match = text.match(pattern);
                if (match) {
                    let nationality = match[1];
                    // Convert common codes
                    if (nationality === 'GBR') nationality = 'BRITISH';
                    return nationality;
                }
            }
            return '';
        }

        function extractDateOfBirth(text, lines) {
            console.log('--- Extracting Date of Birth ---');
            
            const patterns = [
                // UK passport format with field numbers
                /Date of birth\/Date de naissance\s*\(4\)\s*(\d{1,2}[\/\-\.]\d{1,2}[\/\-\.]\d{2,4})/i,
                /\(4\)\s*(\d{1,2}[\/\-\.]\d{1,2}[\/\-\.]\d{2,4})/,
                
                // General date of birth patterns
                /date\s*of\s*birth[:\s\/]*(\d{1,2}[\/\-\.]\d{1,2}[\/\-\.]\d{2,4})/i,
                /birth[:\s\/]*(\d{1,2}[\/\-\.]\d{1,2}[\/\-\.]\d{2,4})/i,
                /dob[:\s]*(\d{1,2}[\/\-\.]\d{1,2}[\/\-\.]\d{2,4})/i,
                
                // DD MMM YY format (common in UK passports)
                /Date of birth[^(]*\(4\)[^0-9]*(\d{1,2}\s+(?:JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC)\s+\d{2,4})/i,
                /\(4\)[^0-9]*(\d{1,2}\s+(?:JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC)\s+\d{2,4})/i,
                
                // Look for dates near "Date of birth" without strict formatting
                /Date of birth[^0-9]*(\d{1,2}[\/\-\.\s]+(?:JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC|[0-9]{1,2})[\/\-\.\s]+\d{2,4})/i,
                
                // Any date format
                /(\d{1,2}[\/\-\.]\d{1,2}[\/\-\.]\d{2,4})/,
                /(\d{1,2}\s+(?:JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC)\s+\d{2,4})/i,
            ];
            
            for (const pattern of patterns) {
                const match = text.match(pattern);
                if (match) {
                    let dateStr = match[1].trim();
                    console.log('Date of birth found:', dateStr, 'using pattern:', pattern);
                    
                    // If it's a 2-digit year, assume it's in 1900s for birth dates
                    if (/\d{1,2}[\/\-\.]\d{1,2}[\/\-\.]\d{2}$/.test(dateStr)) {
                        dateStr = dateStr.replace(/(\d{2})$/, '19$1');
                        console.log('Expanded 2-digit year to:', dateStr);
                    }
                    
                    return dateStr;
                }
            }
            
            console.log('No date of birth found');
            return '';
        }

        function extractDateOfExpiry(text, lines) {
            console.log('--- Extracting Date of Expiry ---');
            console.log('Full text for expiry search:', text);
            
            const patterns = [
                // UK passport format with field numbers - handle bilingual format
                /Date of expiry\/Date d.expiration\s*\(9\)\s*(\d{1,2}\s+[A-Z]{3}[\/\s]*[A-Z]*\s*\d{2,4})/i,
                /\(9\)\s*(\d{1,2}\s+[A-Z]{3}[\/\s]*[A-Z]*\s*\d{2,4})/,
                
                // Handle the bilingual month format like "JUN / JUIN"
                /(\d{1,2}\s+[A-Z]{3}\s*\/\s*[A-Z]+\s+\d{2,4})/i,
                /(\d{1,2}\s+(?:JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC)\s*\/\s*[A-Z]+\s+\d{2,4})/i,
                
                // Standard formats
                /Date of expiry[^(]*\(9\)[^0-9]*(\d{1,2}[\/\-\.\s]+(?:JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC)[\/\-\.\s]*\d{2,4})/i,
                /\(9\)[^0-9]*(\d{1,2}[\/\-\.\s]+(?:JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC)[\/\-\.\s]*\d{2,4})/i,
                
                // General expiry patterns
                /(?:date\s*of\s*)?expiry[:\s\/]*(\d{1,2}[\/\-\.]\d{1,2}[\/\-\.]\d{2,4})/i,
                /expires?[:\s]*(\d{1,2}[\/\-\.]\d{1,2}[\/\-\.]\d{2,4})/i,
                /valid\s*until[:\s]*(\d{1,2}[\/\-\.]\d{1,2}[\/\-\.]\d{2,4})/i,
                
                // Look for dates near "expiry" or field (9) - more flexible
                /expiry[^0-9]*(\d{1,2}[\/\-\.\s]+(?:JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC|[0-9]{1,2})[\/\-\.\s]+\d{2,4})/i,
                
                // Very specific pattern for the format we see: "15 JUN / JUIN 32"
                /(\d{1,2}\s+JUN\s*\/\s*JUIN\s+\d{2})/i,
                /(\d{1,2}\s+[A-Z]{3}\s*\/\s*[A-Z]{4,}\s+\d{2})/i,
            ];
            
            for (const pattern of patterns) {
                const match = text.match(pattern);
                if (match) {
                    let dateStr = match[1].trim();
                    console.log('Date of expiry found:', dateStr, 'using pattern:', pattern);
                    
                    // Clean up bilingual format - remove the second language part
                    dateStr = dateStr.replace(/\s*\/\s*[A-Z]+/g, '');
                    
                    // If it's a 2-digit year, assume it's in 2000s for expiry dates
                    if (/\d{1,2}\s+[A-Z]{3}\s+\d{2}$/.test(dateStr)) {
                        dateStr = dateStr.replace(/(\d{2})$/, '20$1');
                        console.log('Expanded 2-digit year to:', dateStr);
                    } else if (/\d{1,2}[\/\-\.]\d{1,2}[\/\-\.]\d{2}$/.test(dateStr)) {
                        dateStr = dateStr.replace(/(\d{2})$/, '20$1');
                        console.log('Expanded 2-digit year to:', dateStr);
                    }
                    
                    return dateStr;
                }
            }
            
            // Fallback: look line by line for any date after field (9)
            console.log('Trying line-by-line expiry search...');
            let foundField9 = false;
            for (const line of lines) {
                console.log('Checking line:', line);
                
                if (/\(9\)/.test(line)) {
                    foundField9 = true;
                    console.log('Found field (9) in line');
                }
                
                if (foundField9) {
                    // Look for any date pattern in this line or next few lines
                    const dateMatch = line.match(/(\d{1,2}\s+[A-Z]{3}[\/\s]*[A-Z]*\s*\d{2,4})/);
                    if (dateMatch) {
                        let dateStr = dateMatch[1].trim();
                        console.log('Found expiry date in line after (9):', dateStr);
                        
                        // Clean up bilingual format
                        dateStr = dateStr.replace(/\s*\/\s*[A-Z]+/g, '');
                        
                        // Expand 2-digit year
                        if (/\d{2}$/.test(dateStr)) {
                            dateStr = dateStr.replace(/(\d{2})$/, '20$1');
                        }
                        
                        return dateStr;
                    }
                }
            }
            
            console.log('No date of expiry found');
            return '';
        }

        function extractPlaceOfBirth(text, lines) {
            const patterns = [
                /place\s*of\s*birth[:\s]+([A-Z][A-Z\s,]+?)(?:\n|date|sex|nationality)/i,
                /born[:\s]+([A-Z][A-Z\s,]+?)(?:\n|date|sex)/i,
                /pob[:\s]+([A-Z][A-Z\s,]+?)(?:\n|date)/i,
            ];
            
            for (const pattern of patterns) {
                const match = text.match(pattern);
                if (match) {
                    return match[1].trim();
                }
            }
            return '';
        }

        function extractSex(text, lines) {
            const patterns = [
                /sex[:\s]+([MF])/i,
                /gender[:\s]+([MF])/i,
                /\b([MF])\b/,
            ];
            
            for (const pattern of patterns) {
                const match = text.match(pattern);
                if (match) {
                    return match[1].toUpperCase();
                }
            }
            return '';
        }

        // Enhanced pattern extraction helper
        function extractPattern(text, pattern) {
            const match = text.match(pattern);
            return match ? match[1].trim() : null;
        }

        // Replace the existing passport extraction in your main function
        function extractDocumentData(text, docType) {
            console.log('=== DOCUMENT DATA EXTRACTION ===');
            console.log('Document type:', docType);
            console.log('Input text:', text);
            
            if (docType === 'passport') {
                return extractPassportData(text);
            } else {
                // Keep existing driving license extraction logic
                const data = {};
                data['Document Type'] = 'UK Driving License';
                
                // More flexible patterns for UK license
                data['1. Surname'] = extractPattern(text, /1\.?\s*([A-Z]+)/i) ||
                                    extractPattern(text, /GROOMS/i) ||
                                    extractPattern(text, /^([A-Z]{4,})$/m);
                
                data['2. Given Names'] = extractPattern(text, /2\.?\s*([A-Z\s]+)/i) ||
                                        extractPattern(text, /(MR\s+[A-Z\s]+)/i) ||
                                        extractPattern(text, /(DAVID\s+JOHN)/i);
                
                data['3. Date of Birth'] = extractPattern(text, /3\.?\s*(\d{2}\.\d{2}\.\d{4})/i) ||
                                          extractPattern(text, /(\d{2}\.\d{2}\.\d{4})/);
                
                data['4a. Date of Issue'] = extractPattern(text, /4a\.?\s*(\d{2}\.\d{2}\.\d{4})/i);
                data['4b. Date of Expiry'] = extractPattern(text, /4b\.?\s*(\d{2}\.\d{2}\.\d{4})/i);
                data['4c. Authority'] = extractPattern(text, /4c\.?\s*([A-Z]+)/i) ||
                                       extractPattern(text, /(DVLA)/i);
                
                data['5. License Number'] = extractPattern(text, /5\.?\s*([A-Z]{5}\d{6}[A-Z0-9]{5}(?:\s*\d{2})?)/i) ||
                                           extractPattern(text, /([A-Z]{5}\d{6}[A-Z0-9]{5}(?:\s*\d{2})?)/);
                
                // Validate the licence number
                if (!data['5. License Number'] || !validateDrivingLicenceNumber(data['5. License Number'])) {
                    // Try alternative patterns including with spaces
                    const licencePatterns = [
                        /GROOM[A-Z0-9]{11}(?:\s*\d{2})?/i,
                        /[A-Z]{5}\d{6}[A-Z0-9]{5}\s*\d{2}/,
                        /[A-Z]{5}\d{6}[A-Z0-9]{5}/,
                        /([A-Z]{5})\s*(\d{6})\s*([A-Z0-9]{5})(?:\s*(\d{2}))?/
                    ];
                    
                    for (const pattern of licencePatterns) {
                        const match = text.match(pattern);
                        if (match) {
                            const potentialLicence = match[0].trim();
                            if (validateDrivingLicenceNumber(potentialLicence)) {
                                data['5. License Number'] = potentialLicence;
                                console.log('Found valid licence number:', potentialLicence);
                                break;
                            }
                        }
                    }
                    
                    if (!data['5. License Number']) {
                        console.warn('No valid UK driving licence number found');
                    }
                }
                
                // Address extraction - look for actual address patterns
                data['8. Address'] = extractPattern(text, /8\.?\s*([A-Z0-9\s,]+(?:CLOSE|STREET|ROAD|AVENUE)[A-Z0-9\s,]*)/i) ||
                                    extractPattern(text, /(WHEELWRIGHT\s+CLOSE[A-Z0-9\s,]*)/i) ||
                                    extractPattern(text, /(EASTBOURNE[A-Z0-9\s,]*)/i) ||
                                    extractPattern(text, /(\d+\s+[A-Z\s]+(?:CLOSE|STREET|ROAD)[A-Z0-9\s,]*)/i);
                
                data['9. Categories'] = extractPattern(text, /9\.?\s*([A-Z\/\d\s]+)/i) ||
                                       extractPattern(text, /(AM\/A\/B1\/B\/C1\/D1\/BE\/C1E\/D1E)/i);
                
                // Extract postcode separately
                data['Postcode'] = extractPattern(text, /([A-Z]{1,2}\d{1,2}[A-Z]?\s*\d[A-Z]{2})/i) ||
                                  extractPattern(text, /(BN22\s*0XG)/i);
                
                return data;
            }
        }

        function displayOCRResults() {
            const confidenceElement = document.getElementById('confidenceScore');
            const resultsElement = document.getElementById('ocrResults');
            
            const text = ocrData.text || '';
            console.log('Processing text for field extraction:', text);
            
            // Use the new extraction function
            const extractedData = extractDocumentData(text, selectedDocType);
            
            // Get only the fields we want to display for each document type
            let displayFields = {};
            let essentialFields = [];
            
            if (selectedDocType === 'passport') {
                displayFields = {
                    'Surname': extractedData['Surname'] || '',
                    'Given Names': extractedData['Given Names'] || '',
                    'Passport Number': extractedData['Passport Number'] || '',
                    'Nationality': extractedData['Nationality'] || '',
                    'Date of Birth': extractedData['Date of Birth'] || '',
                    'Date of Expiry': extractedData['Date of Expiry'] || ''
                };
                
                // Essential fields for passport
                essentialFields = ['Surname', 'Given Names', 'Passport Number'];
                
                // Validate passport number format
                if (displayFields['Passport Number'] && !validatePassportNumber(displayFields['Passport Number'])) {
                    console.warn('Invalid passport number format:', displayFields['Passport Number']);
                }
                
            } else {
                // Driving license fields
                displayFields = {
                    'Surname': extractedData['1. Surname'] || extractedData['Surname'] || '',
                    'Given Names': extractedData['2. Given Names'] || extractedData['Given Names'] || '',
                    'Licence Number': extractedData['5. License Number'] || extractedData['License Number'] || '',
                    'Date of Birth': extractedData['3. Date of Birth'] || '',
                    'Authority': extractedData['4c. Authority'] || ''
                };
                
                // Essential fields for driving license
                essentialFields = ['Surname', 'Given Names', 'Licence Number'];
            }
            
            // Calculate confidence based on extracted fields
            let fieldsFound = 0;
            let essentialFieldsFound = 0;
            let numberFieldFound = false;
            
            console.log('=== FIELD VALIDATION ===');
            
            Object.entries(displayFields).forEach(([key, value]) => {
                const hasValue = value && value.trim() !== '' && value !== 'Not detected';
                console.log(`${key}: "${value}" - Valid: ${hasValue}`);
                
                if (hasValue) {
                    fieldsFound++;
                    
                    // Check if this is an essential field
                    if (essentialFields.includes(key)) {
                        essentialFieldsFound++;
                        
                        // Special validation for number fields
                        if (key.includes('Number') || key.includes('Licence Number')) {
                            if (selectedDocType === 'passport') {
                                numberFieldFound = validatePassportNumber(value);
                            } else {
                                numberFieldFound = validateDrivingLicenceNumber(value);
                            }
                            console.log(`${key} validation result:`, numberFieldFound);
                        }
                    }
                }
            });
            
            console.log('Fields found:', fieldsFound, 'Essential fields found:', essentialFieldsFound, 'Number field valid:', numberFieldFound);
            
            // Calculate confidence score
            if (!numberFieldFound) {
                confidenceScore = 0;
                console.log('Confidence set to 0 - no valid document number');
            } else if (essentialFieldsFound === essentialFields.length) {
                confidenceScore = 100;
                console.log('Confidence set to 100 - all essential fields found');
            } else {
                // Proportional score based on essential fields found
                confidenceScore = Math.round((essentialFieldsFound / essentialFields.length) * 100);
                console.log(`Confidence set to ${confidenceScore} - ${essentialFieldsFound}/${essentialFields.length} essential fields`);
            }
            
            // Display confidence score with appropriate styling and messaging
            if (confidenceScore === 0) {
                confidenceElement.className = 'confidence-score low';
                confidenceElement.textContent = `âŒ Document Number Not Found or Invalid`;
            } else if (confidenceScore < 100) {
                confidenceElement.className = 'confidence-score medium';
                confidenceElement.textContent = `âš ï¸ Confidence: ${confidenceScore}% - Some Essential Fields Missing`;
            } else {
                confidenceElement.className = 'confidence-score';
                confidenceElement.textContent = `âœ… Confidence: 100% - All Essential Fields Detected`;
            }
            
            // Display the extracted fields with clear status indicators
            let resultsHTML = `<h3>ðŸ“„ Extracted Information (${selectedDocType.charAt(0).toUpperCase() + selectedDocType.slice(1)}):</h3>`;
            
            Object.entries(displayFields).forEach(([key, value]) => {
                const hasValue = value && value.trim() !== '' && value !== 'Not detected';
                const isEssential = essentialFields.includes(key);
                const isValid = hasValue && (!key.includes('Number') && !key.includes('Licence Number') || 
                                (selectedDocType === 'passport' && validatePassportNumber(value)) ||
                                (selectedDocType !== 'passport' && validateDrivingLicenceNumber(value)));
                
                let statusIcon = '';
                let statusColor = '';
                let displayValue = hasValue ? value : 'Not detected';
                
                if (isEssential) {
                    if (isValid) {
                        statusIcon = 'âœ…';
                        statusColor = '#28a745';
                    } else if (hasValue) {
                        statusIcon = 'âš ï¸';
                        statusColor = '#ffc107';
                        displayValue += ' (Invalid format)';
                    } else {
                        statusIcon = 'âŒ';
                        statusColor = '#dc3545';
                    }
                } else {
                    if (hasValue) {
                        statusIcon = 'âœ“';
                        statusColor = '#6c757d';
                    } else {
                        statusIcon = 'â—‹';
                        statusColor = '#dee2e6';
                    }
                }
                
                resultsHTML += `
                    <div class="data-item">
                        <span class="data-label">
                            ${statusIcon} ${key}${isEssential ? ' *' : ''}:
                        </span>
                        <span class="data-value" style="color: ${statusColor};">
                            ${displayValue}
                        </span>
                    </div>
                `;
            });
            
            // Add legend
            resultsHTML += `
                <div style="background: #e3f2fd; color: #1565c0; padding: 15px; border-radius: 8px; margin: 15px 0; font-size: 12px;">
                    <strong>Extraction Summary:</strong><br>
                    Essential Fields: ${essentialFieldsFound}/${essentialFields.length} detected<br>
                    Total Fields: ${fieldsFound}/${Object.keys(displayFields).length} detected<br>
                    <em>* Essential fields required for verification</em>
                </div>
            `;
            
            // Add raw text preview for debugging
            if (text && text.length > 20) {
                resultsHTML += `
                    <details style="margin-top: 20px;">
                        <summary style="cursor: pointer; color: #6c757d; font-size: 14px;">ðŸ” View Raw OCR Text</summary>
                        <div class="raw-text">${text}</div>
                    </details>
                `;
            }
            
            resultsElement.innerHTML = resultsHTML;
        }

        // Simplified validation function for mobile compatibility
        function validateAndProceed() {
            console.log('validateAndProceed called - starting validation');
            
            try {
                const input = document.getElementById('idRefInput');
                console.log('Input element found:', !!input);
                
                if (!input) {
                    alert('Error: Input field not found. Please refresh the page.');
                    return;
                }
                
                const value = input.value ? input.value.trim() : '';
                console.log('Input value:', value, 'Length:', value.length);
                
                if (!value) {
                    alert('Please enter an ID Reference number.');
                    input.focus();
                    return;
                }
                
                if (value.length !== 6) {
                    alert('ID Reference must be exactly 6 digits.');
                    input.focus();
                    return;
                }
                
                if (!value.startsWith('16')) {
                    alert('ID Reference must start with 16.');
                    input.focus();
                    return;
                }
                
                if (!/^\d{6}$/.test(value)) {
                    alert('ID Reference must contain only numbers.');
                    input.focus();
                    return;
                }
                
                // All validation passed
                idRef = value;
                console.log('ID Ref set successfully:', idRef);
                
                // Update display element
                const displayElement = document.getElementById('displayIdRef');
                if (displayElement) {
                    displayElement.textContent = idRef;
                    console.log('Display element updated');
                } else {
                    console.log('Display element not found yet (will be set later)');
                }
                
                // Move to next step
                console.log('Moving to step 1');
                showStep(1);
                
            } catch (error) {
                console.error('Error in validateAndProceed:', error);
                alert('An error occurred. Please refresh the page and try again.');
            }
        }

        // Simple initialization
        function initApp() {
            console.log('Initializing app...');
            
            // Check URL parameters first
            const urlIDRef = getURLParameter('idref') || getURLParameter('id') || getURLParameter('ref');
            
            if (urlIDRef && urlIDRef.length === 6 && urlIDRef.startsWith('16') && /^\d{6}$/.test(urlIDRef)) {
                console.log('Valid ID Ref from URL:', urlIDRef);
                idRef = urlIDRef;
                
                // Set display if element exists
                const displayElement = document.getElementById('displayIdRef');
                if (displayElement) {
                    displayElement.textContent = idRef;
                }
                
                showStep(1);
            } else {
                console.log('No valid URL ID Ref, showing step 0');
                showStep(0);
                
                // Focus input after a short delay to ensure it's rendered
                setTimeout(() => {
                    const input = document.getElementById('idRefInput');
                    if (input) {
                        input.focus();
                        console.log('Input focused');
                    }
                }, 100);
            }
        }

        // Wait for page to fully load
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initApp);
        } else {
            initApp();
        }

        function updateHeaderWithIDRef() {
            const headerElement = document.querySelector('.header');
            if (headerElement && idRef) {
                const idRefDisplay = document.createElement('p');
                idRefDisplay.style.cssText = 'margin-top: 10px; font-size: 14px; opacity: 0.9;';
                idRefDisplay.innerHTML = `ID Reference: <strong>${idRef}</strong>`;
                headerElement.appendChild(idRefDisplay);
            }
        }

        async function processOCR() {
            try {
                const processingText = document.getElementById('processingText');
                
                processingText.textContent = 'Initializing OCR engine...';
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                // Check if Tesseract is loaded
                if (typeof Tesseract === 'undefined') {
                    throw new Error('OCR library not loaded');
                }
                
                processingText.textContent = 'Creating OCR worker...';
                const worker = await Tesseract.createWorker('eng', 1, {
                    logger: m => {
                        console.log('OCR Progress:', m);
                        if (m.status === 'recognizing text') {
                            const progress = Math.floor(m.progress * 100);
                            processingText.textContent = `Extracting text: ${progress}%`;
                        } else if (m.status) {
                            processingText.textContent = m.status.replace(/_/g, ' ') + '...';
                        }
                    }
                });
                
                // Configure for better document recognition
                await worker.setParameters({
                    tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789.,:/- ()[]',
                    tessedit_pageseg_mode: Tesseract.PSM.SINGLE_BLOCK,
                });
                
                processingText.textContent = 'Processing your document...';
                
                const { data } = await worker.recognize(documentImage);
                await worker.terminate();
                
                console.log('Real OCR Result:', data);
                console.log('Extracted Text:', data.text);
                
                ocrData = data;
                confidenceScore = Math.floor(data.confidence || 0);
                
                showStep(4);
                displayOCRResults();
                
            } catch (error) {
                console.error('OCR Error:', error);
                
                // Fallback to manual processing if OCR fails
                const processingText = document.getElementById('processingText');
                processingText.textContent = 'OCR failed, using image analysis...';
                
                // Simple fallback analysis
                ocrData = {
                    text: 'OCR processing failed. Manual review required.',
                    confidence: 0
                };
                confidenceScore = 0;
                
                showStep(4);
                displayOCRResults();
            }
        }

        function showStep(step) {
            console.log('showStep called with step:', step);
            
            try {
                // Hide all steps
                const allSteps = document.querySelectorAll('.step');
                console.log('Found steps:', allSteps.length);
                
                allSteps.forEach(s => s.classList.remove('active'));
                
                // Show target step
                const targetStep = document.getElementById(`step${step}`);
                if (targetStep) {
                    targetStep.classList.add('active');
                    console.log('Step', step, 'activated');
                } else {
                    console.error('Step element not found:', `step${step}`);
                }
                
                currentStep = step;
                
                // Handle header visibility
                const mainHeader = document.getElementById('mainHeader');
                if (mainHeader) {
                    if (step === 0) {
                        mainHeader.style.display = 'block';
                        console.log('Main header shown');
                    } else {
                        mainHeader.style.display = 'none';
                        console.log('Main header hidden');
                    }
                }
                
                // Update ID ref display if moving to step 1 and idRef is set
                if (step === 1 && idRef) {
                    const displayElement = document.getElementById('displayIdRef');
                    if (displayElement) {
                        displayElement.textContent = idRef;
                        console.log('Updated displayIdRef with:', idRef);
                    }
                }
                
            } catch (error) {
                console.error('Error in showStep:', error);
            }
        }

        function selectDocument(type) {
            selectedDocType = type;
            document.getElementById('docType').textContent = type === 'passport' ? 'Passport' : 'Driving Licence';
            
            // Go directly to scanning - let camera initialize naturally
            showStep(2);
            initCamera();
        }

        async function requestCameraPermission() {
            console.log('Requesting camera permission (one time only)...');
            
            try {
                // Request basic video access - this will prompt for permission once
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: true // Simple request - no specific camera constraints
                });
                
                console.log('Camera permission granted successfully');
                
                // Stop the stream immediately - we just wanted permission
                stream.getTracks().forEach(track => track.stop());
                
                return true;
            } catch (error) {
                console.error('Camera permission error:', error);
                throw error;
            }
        }

        async function initCamera() {
            console.log('Initializing camera...');
            
            try {
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                }

                // Simple camera request - browser will ask for permission if needed
                const constraints = {
                    video: { facingMode: currentCamera }
                };
                
                stream = await navigator.mediaDevices.getUserMedia(constraints);
                console.log('Camera stream started successfully');
                cameraPermissionGranted = true; // Mark as granted after successful access

                const video = document.createElement('video');
                video.srcObject = stream;
                video.autoplay = true;
                video.playsInline = true;
                video.style.width = '100%';
                video.style.borderRadius = '12px';
                
                const container = document.getElementById('cameraContainer');
                container.innerHTML = '';
                container.appendChild(video);
                
            } catch (error) {
                console.error('Camera initialization error:', error);
                cameraPermissionGranted = false;
                showCameraFallback('cameraContainer');
            }
        }

        async function initPhotoCamera() {
            console.log('Initializing photo camera...');
            
            try {
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                }

                // Try to reuse existing stream or create new one
                const constraints = {
                    video: { facingMode: 'user' }
                };
                
                stream = await navigator.mediaDevices.getUserMedia(constraints);
                console.log('Photo camera stream started successfully');

                const video = document.createElement('video');
                video.srcObject = stream;
                video.autoplay = true;
                video.playsInline = true;
                video.style.width = '100%';
                video.style.borderRadius = '12px';
                
                const container = document.getElementById('photoContainer');
                container.innerHTML = '';
                container.appendChild(video);
                
            } catch (error) {
                console.error('Photo camera initialization error:', error);
                showCameraFallback('photoContainer');
            }
        }

        function showCameraFallback(containerId) {
            const container = document.getElementById(containerId);
            const isPhoto = containerId === 'photoContainer';
            
            container.innerHTML = `
                <div style="text-align: center; padding: 20px;">
                    <div style="font-size: 48px; margin-bottom: 15px;">${isPhoto ? 'ðŸ¤³' : 'ðŸ“'}</div>
                    <p style="margin-bottom: 15px;">Camera not available</p>
                    <p style="margin-bottom: 15px; font-size: 14px; color: #666;">
                        ${isPhoto ? 'Upload a selfie photo' : 'Upload a photo of your document'}
                    </p>
                    <input type="file" id="${isPhoto ? 'photoFileInput' : 'fileInput'}" 
                           accept="image/*" capture="${isPhoto ? 'user' : 'environment'}" 
                           style="display: none;" 
                           onchange="${isPhoto ? 'handlePhotoUpload(event)' : 'handleFileUpload(event)'}">
                    <button onclick="document.getElementById('${isPhoto ? 'photoFileInput' : 'fileInput'}').click()" 
                            style="background: #004E92; 
                                   color: white; border: none; padding: 12px 24px; 
                                   border-radius: 25px; cursor: pointer;">
                        ${isPhoto ? 'ðŸ“¸ Upload Selfie' : 'ðŸ“· Upload Photo'}
                    </button>
                </div>
            `;
        }

        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = async function(e) {
                    documentImage = e.target.result;
                    
                    // Check for issues
                    const analysis = await detectFingerObstruction(documentImage);
                    
                    const container = document.getElementById('cameraContainer');
                    
                    let statusHTML = '';
                    let borderColor = '#28a745'; // Green by default
                    let statusMessage = 'âœ… Document uploaded';
                    
                    if (analysis.isTooSmall) {
                        borderColor = '#ffc107'; // Yellow warning
                        statusMessage = 'âš ï¸ Document is too small';
                        statusHTML = `<p style="color: #856404; font-size: 14px;">Document fills only ${analysis.fillPercentage.toFixed(0)}% of image</p>`;
                    }
                    
                    if (analysis.hasObstruction) {
                        borderColor = '#dc3545'; // Red error
                        statusMessage = 'âš ï¸ Finger blocking text area';
                        statusHTML = `<p style="color: #dc3545; font-size: 14px;">Please ensure fingers are only on edges</p>`;
                    }
                    
                    container.innerHTML = `
                        <div style="text-align: center; padding: 20px;">
                            <img src="${e.target.result}" style="max-width: 100%; max-height: 250px; border-radius: 8px; border: 3px solid ${borderColor};">
                            <p style="color: ${borderColor}; margin-top: 10px; font-weight: bold;">${statusMessage}</p>
                            ${statusHTML}
                            ${(analysis.isTooSmall || analysis.hasObstruction) ? `
                                <button onclick="document.getElementById('fileInput').click()" 
                                        style="background: ${borderColor}; 
                                               color: white; border: none; padding: 10px 20px; 
                                               border-radius: 25px; cursor: pointer; margin-top: 10px;">
                                    ðŸ“· Upload Different Photo
                                </button>
                            ` : ''}
                        </div>
                    `;
                };
                reader.readAsDataURL(file);
            }
        }

        function handlePhotoUpload(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = async function(e) {
                    photoImage = e.target.result;
                    
                    // Check if uploaded image contains a person
                    const isPersonDetected = await detectPerson(photoImage);
                    
                    if (isPersonDetected) {
                        const container = document.getElementById('photoContainer');
                        container.innerHTML = `
                            <div style="text-align: center; padding: 20px;">
                                <img src="${e.target.result}" style="max-width: 100%; max-height: 250px; border-radius: 8px;">
                                <p style="color: #28a745; margin-top: 10px;">âœ… Photo uploaded</p>
                            </div>
                        `;
                    } else {
                        alert('No person detected in the uploaded photo. Please upload a clear photo of yourself.');
                        photoImage = null;
                        // Reset the file input
                        event.target.value = '';
                    }
                };
                reader.readAsDataURL(file);
            }
        }

        function switchCamera() {
            currentCamera = currentCamera === 'environment' ? 'user' : 'environment';
            initCamera();
        }

        function switchPhotoCamera() {
            initPhotoCamera();
        }

        async function detectFingerObstruction(imageData) {
            try {
                const img = new Image();
                img.src = imageData;
                
                return new Promise((resolve) => {
                    img.onload = async () => {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        ctx.drawImage(img, 0, 0);
                        
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const data = imageData.data;
                        
                        // First, try to detect the document boundaries
                        let documentBounds = findDocumentBounds(data, canvas.width, canvas.height);
                        
                        // If we found document bounds, check for fingers ONLY within the document area
                        let centerFleshPixels = 0;
                        let documentPixels = 0;
                        
                        // Define the central text area of a typical ID (middle 60% both ways)
                        const textAreaLeft = documentBounds.minX + (documentBounds.width * 0.2);
                        const textAreaRight = documentBounds.maxX - (documentBounds.width * 0.2);
                        const textAreaTop = documentBounds.minY + (documentBounds.height * 0.2);
                        const textAreaBottom = documentBounds.maxY - (documentBounds.height * 0.2);
                        
                        // Only check the text area for obstructions
                        for (let y = textAreaTop; y < textAreaBottom; y++) {
                            for (let x = textAreaLeft; x < textAreaRight; x++) {
                                const i = (Math.floor(y) * canvas.width + Math.floor(x)) * 4;
                                const r = data[i];
                                const g = data[i + 1];
                                const b = data[i + 2];
                                
                                documentPixels++;
                                
                                // Very strict flesh tone detection - only count obvious skin
                                const isDefinitelyFlesh = (
                                    // Standard skin tone with strong red channel
                                    (r > 120 && r < 255 && g > 70 && g < 200 && b > 40 && b < 170 && 
                                     r > g + 20 && r > b + 20 && Math.abs(r - g) > 20)
                                );
                                
                                if (isDefinitelyFlesh) {
                                    centerFleshPixels++;
                                }
                            }
                        }
                        
                        // Calculate percentages
                        const fleshInTextArea = documentPixels > 0 ? (centerFleshPixels / documentPixels) * 100 : 0;
                        const documentFillPercentage = ((documentBounds.width * documentBounds.height) / (canvas.width * canvas.height)) * 100;
                        
                        console.log('Document fill:', documentFillPercentage.toFixed(1) + '%');
                        console.log('Flesh pixels in text area:', centerFleshPixels);
                        console.log('Text area obstruction:', fleshInTextArea.toFixed(2) + '%');
                        
                        // Much higher threshold - only warn if significant portion of text area is blocked
                        const hasFingerObstruction = fleshInTextArea > 15; // Was 2%, now 15%
                        const isTooSmall = documentFillPercentage < 30; // Was 40%, now 30%
                        
                        resolve({
                            hasObstruction: hasFingerObstruction,
                            percentage: fleshInTextArea,
                            isTooSmall: isTooSmall,
                            fillPercentage: documentFillPercentage,
                            edgeFingers: false // Not tracking this anymore
                        });
                    };
                    
                    img.onerror = () => {
                        console.error('Failed to load image for analysis');
                        resolve({ hasObstruction: false, percentage: 0, isTooSmall: false, fillPercentage: 100 });
                    };
                });
                
            } catch (error) {
                console.error('Document analysis error:', error);
                return { hasObstruction: false, percentage: 0, isTooSmall: false, fillPercentage: 100 };
            }
        }
        
        function findDocumentBounds(data, width, height) {
            // Simple document detection - find the rectangular area with content
            let minX = width, maxX = 0, minY = height, maxY = 0;
            
            // Sample every 10th pixel for speed
            for (let y = 0; y < height; y += 10) {
                for (let x = 0; x < width; x += 10) {
                    const i = (y * width + x) * 4;
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    
                    // Check if pixel is likely part of document (not too dark, not too bright)
                    const brightness = (r + g + b) / 3;
                    const isDocument = brightness > 40 && brightness < 250;
                    const hasColor = Math.max(Math.abs(r - g), Math.abs(g - b), Math.abs(r - b)) > 10;
                    
                    if (isDocument || hasColor) {
                        if (x < minX) minX = x;
                        if (x > maxX) maxX = x;
                        if (y < minY) minY = y;
                        if (y > maxY) maxY = y;
                    }
                }
            }
            
            // Add some padding
            minX = Math.max(0, minX - 20);
            maxX = Math.min(width, maxX + 20);
            minY = Math.max(0, minY - 20);
            maxY = Math.min(height, maxY + 20);
            
            return {
                minX: minX,
                maxX: maxX,
                minY: minY,
                maxY: maxY,
                width: maxX - minX,
                height: maxY - minY
            };
        }

        async function captureDocument() {
            const container = document.getElementById('cameraContainer');
            const video = container.querySelector('video');
            
            if (video && video.srcObject) {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                ctx.drawImage(video, 0, 0);
                documentImage = canvas.toDataURL('image/jpeg', 1.0);
                
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                }
            }
            
            if (documentImage) {
                // Check for issues
                const analysis = await detectFingerObstruction(documentImage);
                
                // Only warn about serious issues
                if (analysis.isTooSmall && analysis.fillPercentage < 20) {
                    // Only warn if VERY small
                    if (confirm(`âš ï¸ Document is very small (${analysis.fillPercentage.toFixed(0)}% of frame).\n\nPlease move closer for better results.\n\nRetake photo?`)) {
                        initCamera();
                        return;
                    }
                } else if (analysis.hasObstruction && analysis.percentage > 25) {
                    // Only warn if significant text blockage
                    if (confirm(`âš ï¸ Significant obstruction detected in text area.\n\nPlease ensure the text on the ID is clearly visible.\n\nRetake photo?`)) {
                        initCamera();
                        return;
                    }
                }
                
                // Otherwise proceed without warnings
                showStep(3);
                await processAzureOCR();
            } else {
                alert('Please capture or upload a document first.');
            }
        }

        async function processAzureOCR() {
            try {
                const processingText = document.getElementById('processingText');
                
                processingText.textContent = 'Connecting directly to Azure Computer Vision...';
                console.log('=== STARTING AZURE OCR ===');
                console.log('Document image size:', documentImage ? documentImage.length : 'No image');
                
                // Go directly to Azure
                const result = await callAzureAPI(documentImage, processingText);
                
                console.log('=== AZURE RESULT ===', result);
                
                // Store the OCR data BEFORE extracting fields
                ocrData = result;
                
                // Calculate confidence based on actual field extraction success
                const extractedData = extractDocumentData(result.text, selectedDocType);
                
                // Count essential fields found
                let fieldsFound = 0;
                let numberFieldFound = false;
                
                if (selectedDocType === 'passport') {
                    if (extractedData['Surname'] && extractedData['Surname'].trim() !== '') fieldsFound++;
                    if (extractedData['Given Names'] && extractedData['Given Names'].trim() !== '') fieldsFound++;
                    if (extractedData['Passport Number'] && extractedData['Passport Number'].trim() !== '' && validatePassportNumber(extractedData['Passport Number'])) {
                        fieldsFound++;
                        numberFieldFound = true;
                    }
                } else {
                    if (extractedData['1. Surname'] && extractedData['1. Surname'].trim() !== '') fieldsFound++;
                    if (extractedData['2. Given Names'] && extractedData['2. Given Names'].trim() !== '') fieldsFound++;
                    if (extractedData['5. License Number'] && extractedData['5. License Number'].trim() !== '' && validateDrivingLicenceNumber(extractedData['5. License Number'])) {
                        fieldsFound++;
                        numberFieldFound = true;
                    }
                }
                
                // Calculate confidence: 0% if no number, otherwise proportional to fields found
                if (!numberFieldFound) {
                    confidenceScore = 0;
                } else {
                    confidenceScore = Math.round((fieldsFound / 3) * 100);
                }
                
                // Store the OCR text in the global ocrData object
                ocrData = result;
                
                showStep(4);
                displayOCRResults();
                
            } catch (error) {
                console.error('=== AZURE ERROR ===', error);
                
                showStep(4);
                showAzureError(error);
            }
        }

        function calculateConfidenceScore(extractedData, rawText) {
            let baseScore = 50; // Start with base score
            let fieldsDetected = 0;
            let totalFields = Object.keys(extractedData).length;
            
            // Count successfully extracted fields
            Object.values(extractedData).forEach(value => {
                if (value && value.trim() !== '' && value !== 'Not detected') {
                    fieldsDetected++;
                    baseScore += 8; // Add 8 points per detected field
                }
            });
            
            // Bonus points for text length (indicates good OCR)
            if (rawText && rawText.length > 100) {
                baseScore += 10;
            }
            if (rawText && rawText.length > 200) {
                baseScore += 5;
            }
            
            // Field completion percentage bonus
            const completionRate = fieldsDetected / totalFields;
            if (completionRate >= 0.8) {
                baseScore += 15; // High completion bonus
            } else if (completionRate >= 0.6) {
                baseScore += 10; // Medium completion bonus
            } else if (completionRate >= 0.4) {
                baseScore += 5; // Low completion bonus
            }
            
            // Cap at 95%
            const finalScore = Math.min(95, Math.max(30, baseScore));
            
            console.log('Confidence calculation:');
            console.log('- Fields detected:', fieldsDetected, 'of', totalFields);
            console.log('- Completion rate:', (completionRate * 100).toFixed(1) + '%');
            console.log('- Text length:', rawText ? rawText.length : 0);
            console.log('- Final confidence:', finalScore + '%');
            
            return finalScore;
        }

        async function callAzureAPI(imageData, statusElement) {
            console.log('=== CALLING AZURE API ===');
            
            try {
                statusElement.textContent = 'Converting image...';
                
                // Convert base64 to bytes
                const base64Data = imageData.split(',')[1];
                const binaryString = atob(base64Data);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                
                console.log('Image converted to bytes:', bytes.length);
                
                statusElement.textContent = 'Sending to Azure...';
                
                const analyzeUrl = `${AZURE_CONFIG.endpoint}vision/v3.2/read/analyze`;
                console.log('Azure URL:', analyzeUrl);
                console.log('API Key (first 10 chars):', AZURE_CONFIG.apiKey.substring(0, 10));
                
                const analyzeResponse = await fetch(analyzeUrl, {
                    method: 'POST',
                    headers: {
                        'Ocp-Apim-Subscription-Key': AZURE_CONFIG.apiKey,
                        'Content-Type': 'application/octet-stream'
                    },
                    body: bytes
                });
                
                console.log('=== AZURE ANALYZE RESPONSE ===');
                console.log('Status:', analyzeResponse.status);
                console.log('Status Text:', analyzeResponse.statusText);
                console.log('Headers:', Object.fromEntries(analyzeResponse.headers.entries()));
                
                const responseText = await analyzeResponse.text();
                console.log('Response Body:', responseText);
                
                if (!analyzeResponse.ok) {
                    throw new Error(`Azure API ${analyzeResponse.status}: ${responseText}`);
                }
                
                const operationLocation = analyzeResponse.headers.get('Operation-Location');
                console.log('Operation Location:', operationLocation);
                
                if (!operationLocation) {
                    throw new Error('No Operation-Location header received');
                }
                
                // Poll for results
                statusElement.textContent = 'Processing image...';
                
                let attempts = 0;
                const maxAttempts = 20;
                
                while (attempts < maxAttempts) {
                    await new Promise(resolve => setTimeout(resolve, 3000));
                    attempts++;
                    
                    statusElement.textContent = `Processing image... ${attempts * 3}s`;
                    console.log(`=== POLLING ATTEMPT ${attempts} ===`);
                    
                    const resultResponse = await fetch(operationLocation, {
                        headers: {
                            'Ocp-Apim-Subscription-Key': AZURE_CONFIG.apiKey
                        }
                    });
                    
                    console.log('Poll Response Status:', resultResponse.status);
                    
                    if (!resultResponse.ok) {
                        const errorText = await resultResponse.text();
                        console.log('Poll Error:', errorText);
                        continue;
                    }
                    
                    const resultData = await resultResponse.json();
                    console.log('=== AZURE RESULT DATA ===', JSON.stringify(resultData, null, 2));
                    
                    if (resultData.status === 'succeeded') {
                        console.log('=== AZURE SUCCESS ===');
                        
                        const extractedText = extractAzureText(resultData);
                        console.log('=== EXTRACTED TEXT ===');
                        console.log(extractedText);
                        
                        return {
                            text: extractedText,
                            confidence: 85,
                            method: 'Azure Computer Vision v3.2',
                            rawAzureResponse: resultData
                        };
                    } else if (resultData.status === 'failed') {
                        throw new Error('Azure processing failed: ' + JSON.stringify(resultData));
                    }
                    
                    console.log('Azure status:', resultData.status, '- continuing to poll...');
                }
                
                throw new Error('Azure timeout after ' + (maxAttempts * 3) + ' seconds');
                
            } catch (error) {
                console.error('=== AZURE API ERROR ===', error);
                throw error;
            }
        }

        function extractAzureText(azureResult) {
            let text = '';
            
            try {
                if (azureResult.analyzeResult && azureResult.analyzeResult.readResults) {
                    azureResult.analyzeResult.readResults.forEach(page => {
                        if (page.lines) {
                            page.lines.forEach(line => {
                                text += line.text + '\n';
                                console.log('Line found:', line.text);
                            });
                        }
                    });
                }
            } catch (error) {
                console.error('Error extracting text:', error);
                throw new Error('Failed to parse Azure response');
            }
            
            return text.trim();
        }

        function showAzureError(error) {
            const confidenceElement = document.getElementById('confidenceScore');
            const resultsElement = document.getElementById('ocrResults');
            
            confidenceElement.className = 'confidence-score low';
            confidenceElement.textContent = 'Azure OCR Failed - See Details Below';
            
            resultsElement.innerHTML = `
                <div style="color: #dc3545;">
                    <h3>âŒ Azure Computer Vision Error</h3>
                    <p><strong>Error Message:</strong> ${error.message}</p>
                    
                    <div style="background: #f8d7da; padding: 15px; border-radius: 8px; margin: 15px 0;">
                        <h4>Debug Information:</h4>
                        <p><strong>Azure Endpoint:</strong> ${AZURE_CONFIG.endpoint}</p>
                        <p><strong>API Key (first 10):</strong> ${AZURE_CONFIG.apiKey.substring(0, 10)}...</p>
                        <p><strong>Document Image:</strong> ${documentImage ? 'Present (' + Math.round(documentImage.length/1024) + 'KB)' : 'Missing'}</p>
                        <p><strong>Browser:</strong> ${navigator.userAgent.split(' ').slice(-2).join(' ')}</p>
                    </div>
                    
                    <div style="background: #fff3cd; color: #856404; padding: 15px; border-radius: 8px; margin: 15px 0;">
                        <h4>ðŸ” Check Browser Console</h4>
                        <p>Press F12 â†’ Console tab to see detailed Azure API responses</p>
                        <p>Look for "=== AZURE RESULT DATA ===" to see what Azure returned</p>
                    </div>
                    
                    <button class="btn secondary" onclick="testAzureConnection()" style="margin: 10px;">
                        ðŸ” Test Azure Connection
                    </button>
                </div>
            `;
        }

        function retakeDocument() {
            showStep(2);
            initCamera();
        }

        function proceedToPhoto() {
            showStep(5);
            initPhotoCamera();
        }

        async function capturePhoto() {
            const container = document.getElementById('photoContainer');
            const video = container.querySelector('video');
            
            if (video && video.srcObject) {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                ctx.drawImage(video, 0, 0);
                photoImage = canvas.toDataURL('image/jpeg', 1.0);
                
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                }
            }
            
            if (photoImage) {
                // Check if image contains a person
                const isPersonDetected = await detectPerson(photoImage);
                
                if (isPersonDetected) {
                    showStep(6);
                    // Send email with results
                    await sendResultsEmail();
                    setTimeout(() => {
                        showStep(7);
                    }, 3000);
                } else {
                    alert('No person detected in the photo. Please take a clear photo of yourself.');
                    // Restart photo camera
                    initPhotoCamera();
                }
            } else {
                alert('Please capture or upload a photo first.');
            }
        }

        async function createPDFReport(extractedData) {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            
            // Set colors
            const primaryColor = [176, 60, 95]; // #B03C5F
            const darkColor = [51, 51, 51];
            const lightGray = [200, 200, 200];
            
            // Add header
            doc.setFillColor(...primaryColor);
            doc.rect(0, 0, 210, 40, 'F');
            
            // Add title
            doc.setTextColor(255, 255, 255);
            doc.setFontSize(24);
            doc.text('ID Verification Report', 105, 25, { align: 'center' });
            
            // Add company name
            doc.setFontSize(12);
            doc.text('Parfitt Cresswell', 105, 35, { align: 'center' });
            
            // Reset text color
            doc.setTextColor(...darkColor);
            
            // Add report metadata
            let yPos = 55;
            doc.setFontSize(10);
            doc.setTextColor(...lightGray);
            doc.text(`Report Generated: ${new Date().toLocaleString()}`, 20, yPos);
            doc.text(`ID Reference: ${idRef}`, 140, yPos);
            yPos += 15;
            
            // Document type section
            doc.setTextColor(...primaryColor);
            doc.setFontSize(16);
            doc.text('Document Information', 20, yPos);
            yPos += 10;
            
            doc.setDrawColor(...lightGray);
            doc.line(20, yPos, 190, yPos);
            yPos += 10;
            
            // Document details
            doc.setTextColor(...darkColor);
            doc.setFontSize(11);
            
            // Add ID Reference first
            doc.setFont(undefined, 'bold');
            doc.text('ID Reference:', 20, yPos);
            doc.setFont(undefined, 'normal');
            doc.setTextColor(...primaryColor);
            doc.text(idRef, 60, yPos);
            doc.setTextColor(...darkColor);
            yPos += 8;
            
            doc.setFont(undefined, 'bold');
            doc.text('Document Type:', 20, yPos);
            doc.setFont(undefined, 'normal');
            doc.text(selectedDocType.charAt(0).toUpperCase() + selectedDocType.slice(1), 60, yPos);
            yPos += 8;
            
            doc.setFont(undefined, 'bold');
            doc.text('Confidence Score:', 20, yPos);
            doc.setFont(undefined, 'normal');
            const scoreColor = confidenceScore >= 80 ? [40, 167, 69] : confidenceScore >= 60 ? [255, 193, 7] : [220, 53, 69];
            doc.setTextColor(...scoreColor);
            doc.text(`${confidenceScore}%`, 60, yPos);
            doc.setTextColor(...darkColor);
            yPos += 8;
            
            doc.setFont(undefined, 'bold');
            doc.text('Processing Method:', 20, yPos);
            doc.setFont(undefined, 'normal');
            doc.text(ocrData.method || 'Standard OCR', 60, yPos);
            yPos += 15;
            
            // Extracted fields section
            doc.setTextColor(...primaryColor);
            doc.setFontSize(16);
            doc.text('Extracted Information', 20, yPos);
            yPos += 10;
            
            doc.setDrawColor(...lightGray);
            doc.line(20, yPos, 190, yPos);
            yPos += 10;
            
            // Add extracted fields - FIXED to prevent overlapping
            doc.setTextColor(...darkColor);
            doc.setFontSize(11);
            
            Object.entries(extractedData).forEach(([key, value]) => {
                // Check if we need a new page
                if (yPos > 250) {
                    doc.addPage();
                    yPos = 30;
                }
                
                // Set font for label
                doc.setFont(undefined, 'bold');
                doc.text(`${key}:`, 20, yPos);
                
                // Set font and color for value
                doc.setFont(undefined, 'normal');
                const displayValue = value && value.trim() !== '' ? value : 'Not detected';
                const valueColor = displayValue === 'Not detected' ? [220, 53, 69] : [40, 167, 69];
                doc.setTextColor(...valueColor);
                
                // Handle long text by wrapping it
                const maxWidth = 120; // Maximum width for the value text
                const lines = doc.splitTextToSize(displayValue, maxWidth);
                
                // Print first line at the same Y position as the label
                if (lines.length > 0) {
                    doc.text(lines[0], 70, yPos);
                }
                
                // Print additional lines if text was wrapped
                for (let i = 1; i < lines.length; i++) {
                    yPos += 6;
                    if (yPos > 250) {
                        doc.addPage();
                        yPos = 30;
                    }
                    doc.text(lines[i], 70, yPos);
                }
                
                doc.setTextColor(...darkColor);
                yPos += 10; // Add more space between fields
            });
            
            // Add images on new pages with better quality
            if (documentImage) {
                doc.addPage();
                doc.setTextColor(...primaryColor);
                doc.setFontSize(16);
                doc.text('Document Image', 105, 20, { align: 'center' });
                
                try {
                    // Use maximum quality for PDF
                    const imgData = await resizeImage(documentImage, 2000, 2800, 1.0);
                    
                    // Calculate optimal dimensions for A4 page
                    const pageWidth = 210;
                    const pageHeight = 297;
                    const margin = 20;
                    const maxImgWidth = pageWidth - (2 * margin);
                    const maxImgHeight = pageHeight - 60; // Leave space for header
                    
                    // Get actual image dimensions
                    const img = new Image();
                    await new Promise((resolve) => {
                        img.onload = resolve;
                        img.src = imgData;
                    });
                    
                    let imgWidth = img.width;
                    let imgHeight = img.height;
                    
                    // Scale to fit page while maintaining aspect ratio
                    const widthRatio = maxImgWidth / imgWidth;
                    const heightRatio = maxImgHeight / imgHeight;
                    const scale = Math.min(widthRatio, heightRatio, 1); // Don't upscale
                    
                    imgWidth *= scale;
                    imgHeight *= scale;
                    
                    // Center image on page
                    const xPos = (pageWidth - imgWidth) / 2;
                    const yPos = 30;
                    
                    doc.addImage(imgData, 'JPEG', xPos, yPos, imgWidth, imgHeight);
                } catch (error) {
                    console.error('Error adding document image to PDF:', error);
                    doc.setTextColor(...darkColor);
                    doc.setFontSize(11);
                    doc.text('Document image could not be added', 105, 120, { align: 'center' });
                }
            }
            
            if (photoImage) {
                doc.addPage();
                doc.setTextColor(...primaryColor);
                doc.setFontSize(16);
                doc.text('Photo Verification', 105, 20, { align: 'center' });
                
                try {
                    // Use maximum quality for photo
                    const imgData = await resizeImage(photoImage, 1200, 1200, 1.0);
                    
                    // Get actual image dimensions
                    const img = new Image();
                    await new Promise((resolve) => {
                        img.onload = resolve;
                        img.src = imgData;
                    });
                    
                    let imgWidth = img.width;
                    let imgHeight = img.height;
                    
                    // Scale photo to reasonable size (max 120mm wide or tall)
                    const maxPhotoSize = 120;
                    const scale = Math.min(maxPhotoSize / imgWidth, maxPhotoSize / imgHeight, 1);
                    
                    imgWidth *= scale;
                    imgHeight *= scale;
                    
                    // Center image on page
                    const xPos = (210 - imgWidth) / 2;
                    const yPos = 40;
                    
                    doc.addImage(imgData, 'JPEG', xPos, yPos, imgWidth, imgHeight);
                } catch (error) {
                    console.error('Error adding photo to PDF:', error);
                    doc.setTextColor(...darkColor);
                    doc.setFontSize(11);
                    doc.text('Photo could not be added', 105, 90, { align: 'center' });
                }
            }
            
            // Add footer to all pages
            const pageCount = doc.internal.getNumberOfPages();
            for (let i = 1; i <= pageCount; i++) {
                doc.setPage(i);
                doc.setTextColor(...lightGray);
                doc.setFontSize(9);
                doc.text(`Page ${i} of ${pageCount}`, 105, 285, { align: 'center' });
                doc.text('Confidential - Parfitt Cresswell', 20, 285);
            }
            
            // Convert to base64
            const pdfBase64 = doc.output('datauristring').split(',')[1];
            console.log('PDF generated, size:', Math.round(pdfBase64.length / 1024) + 'KB');
            
            return pdfBase64;
        }

        async function sendResultsEmail() {
            try {
                const extractedData = extractDocumentData(ocrData.text || '', selectedDocType);
                
                console.log('=== STARTING SMTP2GO EMAIL SEND ===');
                
                // Convert images to smaller size for email attachment - MAXIMUM QUALITY
                const resizedDocumentImage = await resizeImage(documentImage, 1500, 1200, 1.0);
                const resizedPhotoImage = await resizeImage(photoImage, 800, 1000, 1.0);
                
                // Generate PDF report
                const pdfBase64 = await createPDFReport(extractedData);
                
                // Remove the data:image/jpeg;base64, prefix from images
                const documentBase64 = resizedDocumentImage.split(',')[1];
                const photoBase64 = resizedPhotoImage.split(',')[1];
                
                // Create beautifully formatted HTML email
                const htmlBody = `
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <style>
                            body { font-family: 'Segoe UI', Arial, sans-serif; margin: 0; padding: 0; background-color: #f5f5f5; }
                            .container { max-width: 600px; margin: 0 auto; background-color: #ffffff; }
                            .header { background: linear-gradient(135deg, #a67a7e 0%, #8b6468 100%); color: white; padding: 40px 30px; text-align: center; }
                            .header h1 { margin: 0 0 10px 0; font-size: 28px; font-weight: 300; }
                            .header p { margin: 0; opacity: 0.9; font-size: 14px; }
                            .content { padding: 40px 30px; }
                            .section { margin-bottom: 30px; }
                            .section-title { color: #a67a7e; font-size: 20px; margin: 0 0 20px 0; padding-bottom: 10px; border-bottom: 2px solid #f0f0f0; }
                            .info-grid { display: table; width: 100%; }
                            .info-row { display: table-row; }
                            .info-label { display: table-cell; padding: 8px 15px 8px 0; font-weight: 600; color: #666; width: 40%; vertical-align: top; }
                            .info-value { display: table-cell; padding: 8px 0; color: #333; }
                            .status-badge { display: inline-block; padding: 4px 12px; border-radius: 20px; font-size: 12px; font-weight: 600; }
                            .status-high { background-color: #d4edda; color: #155724; }
                            .status-medium { background-color: #fff3cd; color: #856404; }
                            .status-low { background-color: #f8d7da; color: #721c24; }
                            .extracted-fields { background-color: #f8f9fa; padding: 20px; border-radius: 8px; margin: 20px 0; }
                            .field-item { padding: 10px 0; border-bottom: 1px solid #e9ecef; }
                            .field-item:last-child { border-bottom: none; }
                            .field-name { font-weight: 600; color: #495057; }
                            .field-value { color: #28a745; margin-left: 10px; }
                            .field-value.not-detected { color: #dc3545; }
                            .alert { padding: 15px 20px; border-radius: 8px; margin: 20px 0; }
                            .alert-info { background-color: #e3f2fd; color: #1565c0; border-left: 4px solid #1976d2; }
                            .footer { background-color: #f8f9fa; padding: 30px; text-align: center; color: #6c757d; font-size: 12px; }
                            .footer a { color: #a67a7e; text-decoration: none; }
                            .button { display: inline-block; padding: 12px 30px; background: #a67a7e; color: white; text-decoration: none; border-radius: 25px; margin: 20px 0; }
                            .attachment-notice { background-color: #e8f5e9; padding: 15px; border-radius: 8px; margin: 20px 0; text-align: center; }
                            .attachment-notice h4 { color: #2e7d32; margin: 0 0 10px 0; }
                            .attachment-list { list-style: none; padding: 0; margin: 0; }
                            .attachment-list li { padding: 5px 0; color: #388e3c; }
                        </style>
                    </head>
                    <body>
                        <div class="container">
                            <div class="header" style="background: #B03C5F;">
                                <h1>ID Verification Report</h1>
                                <p>${new Date().toLocaleDateString('en-GB', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' })}</p>
                            </div>
                            
                            <div class="content">
                                <div class="section">
                                    <h2 class="section-title">Verification Summary</h2>
                                    <div class="info-grid">
                                        <div class="info-row">
                                            <div class="info-label">ID Reference:</div>
                                            <div class="info-value"><strong style="color: #B03C5F;">${idRef}</strong></div>
                                        </div>
                                        <div class="info-row">
                                            <div class="info-label">Document Type:</div>
                                            <div class="info-value"><strong>${selectedDocType.charAt(0).toUpperCase() + selectedDocType.slice(1)}</strong></div>
                                        </div>
                                        <div class="info-row">
                                            <div class="info-label">Confidence Score:</div>
                                            <div class="info-value">
                                                <span class="status-badge ${confidenceScore >= 80 ? 'status-high' : confidenceScore >= 60 ? 'status-medium' : 'status-low'}">
                                                    ${confidenceScore}% ${confidenceScore >= 80 ? 'âœ“ Excellent' : confidenceScore >= 60 ? 'âš¡ Good' : 'âš ï¸ Manual Review'}
                                                </span>
                                            </div>
                                        </div>
                                        <div class="info-row">
                                            <div class="info-label">Processing Method:</div>
                                            <div class="info-value">${ocrData.method || 'Azure Computer Vision v3.2'}</div>
                                        </div>
                                        <div class="info-row">
                                            <div class="info-label">Processed At:</div>
                                            <div class="info-value">${new Date().toLocaleString('en-GB')}</div>
                                        </div>
                                    </div>
                                </div>
                                
                                <div class="section">
                                    <h2 class="section-title">Extracted Information</h2>
                                    <div class="extracted-fields">
                                        ${Object.entries(extractedData).map(([key, value]) => `
                                            <div class="field-item">
                                                <span class="field-name">${key}:</span>
                                                <span class="field-value ${!value || value.trim() === '' ? 'not-detected' : ''}">${value && value.trim() !== '' ? value : 'Not detected'}</span>
                                            </div>
                                        `).join('')}
                                    </div>
                                </div>
                                
                                <div class="attachment-notice">
                                    <h4>ðŸ“Ž Attachments Included</h4>
                                    <ul class="attachment-list">
                                        <li>âœ“ Full PDF Report with images</li>
                                        <li>âœ“ Original document image</li>
                                        <li>âœ“ Photo verification image</li>
                                    </ul>
                                </div>
                                
                                ${confidenceScore < 60 ? `
                                <div class="alert alert-info">
                                    <strong>Manual Review Recommended:</strong> The confidence score is below 60%. Please review the attached images and PDF report for manual verification.
                                </div>
                                ` : ''}
                                
                                <div style="text-align: center; margin-top: 30px;">
                                    <p style="color: #6c757d;">This report was automatically generated by the ID Scanner system.</p>
                                </div>
                            </div>
                            
                            <div class="footer">
                                <p><strong>Parfitt Cresswell</strong></p>
                                <p>Secure Document Verification System</p>
                                <p style="margin-top: 15px; font-size: 11px;">
                                    This email and any attachments are confidential and intended solely for the addressee.
                                </p>
                            </div>
                        </div>
                    </body>
                    </html>
                `;
                
                // Create plain text version
                const textBody = `ID VERIFICATION REPORT
=====================

ID Reference: ${idRef}
Document Type: ${selectedDocType.charAt(0).toUpperCase() + selectedDocType.slice(1)}
Confidence Score: ${confidenceScore}%
Processing Method: ${ocrData.method || 'Azure Computer Vision v3.2'}
Timestamp: ${new Date().toLocaleString('en-GB')}

EXTRACTED INFORMATION
--------------------
${Object.entries(extractedData).map(([key, value]) => `${key}: ${value || 'Not detected'}`).join('\n')}

ATTACHMENTS
-----------
- Full PDF Report with images
- Original document image  
- Photo verification image

${confidenceScore < 60 ? '\nNOTE: Manual review recommended due to low confidence score.\n' : ''}

---
Parfitt Cresswell - Secure Document Verification System
This email and any attachments are confidential.`;
                
                // Prepare SMTP2GO API request
                const emailData = {
                    api_key: SMTP2GO_CONFIG.apiKey,
                    to: [
                        'David.grooms@parfittcresswell.com',
                        'mail@davegrooms.co.uk'
                    ],
                    sender: 'ID Scanner <noreply@parfittcresswell.com>',
                    subject: `ID Verification Report - ${selectedDocType.charAt(0).toUpperCase() + selectedDocType.slice(1)} - Ref: ${idRef} [${new Date().toLocaleDateString('en-GB')}]`,
                    html_body: htmlBody,
                    text_body: textBody,
                    attachments: [
                        {
                            filename: `ID_Verification_Report_${selectedDocType}_${Date.now()}.pdf`,
                            fileblob: pdfBase64,
                            mimetype: 'application/pdf'
                        },
                        {
                            filename: `document_${selectedDocType}_${Date.now()}.jpg`,
                            fileblob: documentBase64,
                            mimetype: 'image/jpeg'
                        },
                        {
                            filename: `photo_verification_${Date.now()}.jpg`,
                            fileblob: photoBase64,
                            mimetype: 'image/jpeg'
                        }
                    ]
                };
                
                console.log('ðŸ“§ Sending enhanced email via SMTP2GO...');
                console.log('Recipients:', emailData.to);
                console.log('Subject:', emailData.subject);
                console.log('Attachments:', emailData.attachments.map(a => `${a.filename} (${Math.round(a.fileblob.length/1024)}KB)`));
                
                // Send email via SMTP2GO API
                const response = await fetch(SMTP2GO_CONFIG.apiUrl + 'email/send', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify(emailData)
                });
                
                const result = await response.json();
                
                console.log('SMTP2GO Response:', result);
                
                if (response.ok && result.data && result.data.succeeded > 0) {
                    console.log('âœ… Enhanced email sent successfully via SMTP2GO!');
                    console.log('Email ID:', result.data.email_id);
                    console.log('Succeeded:', result.data.succeeded);
                } else {
                    throw new Error(result.data ? result.data.error || 'Email sending failed' : 'Unknown error');
                }
                
            } catch (error) {
                console.error('âŒ Email sending failed:', error);
                console.error('Full error:', error);
                
                // Show fallback information
                const extractedData = extractDocumentData(ocrData.text || '', selectedDocType);
                console.log('ðŸ“§ EMAIL DATA FOR MANUAL SENDING:');
                console.log('To: David.grooms@parfittcresswell.com, mail@davegrooms.co.uk');
                console.log('Subject: ID Verification Results - ' + selectedDocType);
                console.log('Extracted Data:', extractedData);
                console.log('Confidence:', confidenceScore + '%');
                console.log('Raw Text:', ocrData.text);
                
                alert('Email sending failed. Check console for details and manual sending data.');
            }
        }

        // Helper function to resize images for email - MAXIMUM QUALITY
        async function resizeImage(base64Image, maxWidth, maxHeight, quality = 1.0) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = function() {
                    const canvas = document.createElement('canvas');
                    let width = img.width;
                    let height = img.height;
                    
                    // Calculate new dimensions while maintaining aspect ratio
                    if (width > height) {
                        if (width > maxWidth) {
                            height = Math.round((height * maxWidth) / width);
                            width = maxWidth;
                        }
                    } else {
                        if (height > maxHeight) {
                            width = Math.round((width * maxHeight) / height);
                            height = maxHeight;
                        }
                    }
                    
                    canvas.width = width;
                    canvas.height = height;
                    
                    const ctx = canvas.getContext('2d');
                    // Enable image smoothing for better quality
                    ctx.imageSmoothingEnabled = true;
                    ctx.imageSmoothingQuality = 'high';
                    ctx.drawImage(img, 0, 0, width, height);
                    
                    // Convert to base64 with maximum quality
                    const resizedBase64 = canvas.toDataURL('image/jpeg', quality);
                    
                    console.log(`Image resized from ${img.width}x${img.height} to ${width}x${height}`);
                    console.log(`Quality: ${quality * 100}%, Size: ${Math.round(resizedBase64.length/1024)}KB`);
                    
                    resolve(resizedBase64);
                };
                img.src = base64Image;
            });
        }

        function createPDFData(emailData) {
            // Create a structured data object that could be used to generate a PDF
            return {
                title: 'ID Verification Report',
                documentType: emailData.documentType,
                timestamp: new Date().toLocaleString(),
                confidence: emailData.confidenceScore + '%',
                extractedFields: emailData.extractedFields,
                processingMethod: emailData.processingMethod,
                images: {
                    document: emailData.documentImage ? 'Included' : 'None',
                    photo: emailData.photoImage ? 'Included' : 'None'
                },
                rawText: emailData.rawOcrText
            };
        }

        async function detectPerson(imageData) {
            try {
                // Create a temporary image element to analyze
                const img = new Image();
                img.src = imageData;
                
                return new Promise((resolve) => {
                    img.onload = async () => {
                        try {
                            // Use a simple face detection approach
                            const canvas = document.createElement('canvas');
                            const ctx = canvas.getContext('2d');
                            canvas.width = img.width;
                            canvas.height = img.height;
                            ctx.drawImage(img, 0, 0);
                            
                            // Get image data for analysis
                            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                            const data = imageData.data;
                            
                            // More lenient person detection
                            let skinPixels = 0;
                            let totalPixels = data.length / 4;
                            
                            // Check for skin tones with broader ranges
                            for (let i = 0; i < data.length; i += 4) {
                                const r = data[i];
                                const g = data[i + 1];
                                const b = data[i + 2];
                                
                                // Broader skin tone detection
                                const isSkinTone1 = r > 60 && g > 30 && b > 15 && r > b; // Basic skin detection
                                const isSkinTone2 = r > 160 && g > 100 && b > 80; // Light skin
                                const isSkinTone3 = r > 120 && g > 80 && b > 50 && r > b; // Medium skin
                                const isSkinTone4 = r > 80 && g > 50 && b > 30 && r > b; // Darker skin
                                const isSkinTone5 = r > 200 && g > 170 && b > 140; // Very light skin
                                
                                // Also check for flesh-like colors
                                const rToG = r / (g + 1);
                                const rToB = r / (b + 1);
                                const isFleshLike = rToG > 1.1 && rToB > 1.2 && r > 60;
                                
                                if (isSkinTone1 || isSkinTone2 || isSkinTone3 || isSkinTone4 || isSkinTone5 || isFleshLike) {
                                    skinPixels++;
                                }
                            }
                            
                            // Calculate percentages
                            const skinPercentage = (skinPixels / totalPixels) * 100;
                            
                            console.log('=== PERSON DETECTION ANALYSIS ===');
                            console.log('Image dimensions:', canvas.width, 'x', canvas.height);
                            console.log('Total pixels analyzed:', totalPixels);
                            console.log('Skin tone pixels found:', skinPixels);
                            console.log('Skin tone percentage:', skinPercentage.toFixed(2) + '%');
                            
                            // Much more lenient criteria
                            const hasMinimalSkin = skinPercentage > 1.5; // Just 1.5% skin tone
                            const reasonableSize = totalPixels > 5000; // Lower minimum size
                            
                            // Additional check: look for variety in colors (faces have variation)
                            let colorVariety = 0;
                            const colorBuckets = new Set();
                            for (let i = 0; i < data.length; i += 16) { // Sample every 4th pixel
                                const r = Math.floor(data[i] / 32) * 32;
                                const g = Math.floor(data[i + 1] / 32) * 32;
                                const b = Math.floor(data[i + 2] / 32) * 32;
                                colorBuckets.add(`${r}-${g}-${b}`);
                            }
                            colorVariety = colorBuckets.size;
                            const hasColorVariety = colorVariety > 20; // At least some color variation
                            
                            const isPersonDetected = hasMinimalSkin && reasonableSize && hasColorVariety;
                            
                            console.log('=== DETECTION CRITERIA ===');
                            console.log('Has minimal skin (>1.5%):', hasMinimalSkin);
                            console.log('Reasonable image size:', reasonableSize);
                            console.log('Color variety count:', colorVariety);
                            console.log('Has color variety (>20):', hasColorVariety);
                            console.log('FINAL RESULT: Person detected =', isPersonDetected);
                            
                            // If still no detection but there's some skin, be more lenient
                            if (!isPersonDetected && skinPercentage > 0.5) {
                                console.log('FALLBACK: Accepting due to some skin tone detected');
                                resolve(true);
                            } else {
                                resolve(isPersonDetected);
                            }
                            
                        } catch (error) {
                            console.error('Person detection error:', error);
                            // If detection fails, be more lenient and allow
                            resolve(true);
                        }
                    };
                    
                    img.onerror = () => {
                        console.error('Failed to load image for person detection');
                        // If image load fails, allow the photo
                        resolve(true);
                    };
                });
                
            } catch (error) {
                console.error('Person detection error:', error);
                // If detection fails completely, allow the photo
                return true;
            }
        }

        function startOver() {
            currentStep = 0;
            selectedDocType = '';
            documentImage = null;
            photoImage = null;
            ocrData = null;
            confidenceScore = 0;
            idRef = '';
            cameraPermissionGranted = false; // Reset camera permission
            
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                stream = null;
            }
            
            // Clear the ID input
            const idRefInput = document.getElementById('idRefInput');
            if (idRefInput) {
                idRefInput.value = '';
            }
            
            showStep(0);
        }

        // Add test Azure connection function
        async function testAzureConnection() {
            try {
                console.log('=== TESTING AZURE CONNECTION ===');
                alert('Testing Azure connection... Check console for details.');
                
                // Create a simple test image
                const canvas = document.createElement('canvas');
                canvas.width = 200;
                canvas.height = 100;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, 200, 100);
                ctx.fillStyle = 'black';
                ctx.font = '30px Arial';
                ctx.fillText('TEST', 50, 60);
                
                const testImage = canvas.toDataURL('image/jpeg');
                const statusElement = document.createElement('div');
                
                const result = await callAzureAPI(testImage, statusElement);
                console.log('Test successful:', result);
                alert('Azure connection test successful! Check console for details.');
                
            } catch (error) {
                console.error('Test failed:', error);
                alert('Azure connection test failed. Error: ' + error.message);
            }
        }

        window.addEventListener('beforeunload', () => {
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
            }
        });
    </script>
</body>
</html>